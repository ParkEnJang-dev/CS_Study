



### 소켓 통신 이해하기
---
- 패킷(Packet) : 네트워크 전송 기본단위, 하나의 정보는 여러개의 패킷으로 전송되며, 출발지와 목적지 정보(메타데이터)와 실제 전송되는 데이터(payloa)로 구성
- 소켓(Socket) : 패킷을 전송하기 위한 통로
- 채널(Channel) : 서버와 클라이언트 간에 데이터 전송 경로, 송신자에서 수신자로 전달, 데이터의 전송 방향(일방향 양방향) 전송모드(단일대화 또는 다중 대화)에 따라 구분
- 클라이언트 : 데이터 요청 
- 서버 : 데이터 받는쪽
- TCP : 연결 지향 프로토콜, 데이터 전송전 송수신자 간의 연결 설정, 그 후 패킷으로 나누어 전송하고 패킷이 이 수신자에게 전송되었는지 확인
- UDP : 비연결 지향 프로토콜, 패킷을 수신자에 보내고 정확히 도착했는지 확인 안함, TCP보다는 빠르지마 패킷 순서나 손실에 대한 보장이 없어 신뢰성이 낮음
- HandShake : 각각 네트워크에서 연결을 설정하는 단계를 의미, 이는 통신이 시작되기 전에 두 장치 사이에 세션을 설정하고 서로 데이터 전송을 준비하는 과정.

#### 클라이언트 - 서버, 피어-투-피어 패턴 차이점
- 클라이언트 서버는 서버가 중앙에 위치해 있고 클라이언트가 서버에 연결하여 데이터 공유 받음
- 피어-투-피어 패턴은 모든 노드가 서로 동등한 관계로 데이터를 공유하는 교환하는 구조입니다.


### 핸드셰이킹(HandShaking)
---
- 사람들이 처음 만났을때 손을 잡는것으로 부터 유래

- 3-Way 핸드셰이크 
	- 네트워크 연결 단계, 두장치가 서로 데이터를 제대로 보내고 받을 수 있음을 확인
	- SYN(Synchronize) : 동기화 패킷으로 TCP 연결 초기화 하는데 사용, 클라이언트가 서버에 연결을 시작하고자 할때 보내집니다.
	- SYN-ACK(Synchronize-Acknowledgement) :  동기화 패킷 대한 응답 SYN 서버 -> 클라이언트에게 보내지는 패킷, 이 패킷을 통해 서버가 클라이언트의 연결 요청을 수락하고 클라이언트와 서버 간의 연결이 성립되었음을 나타냄.
	- ACK(Acknowledgment) : 확인(Acknowledgment) 패킷으로 데이터가 성공적으로 수신되었음을 보내는 측에 알리는데 사용.

![](attachments/Pasted%20image%2020260128224817.png)

- 4-Way 핸드셰이크
	- 네트워크에서 연결이 되고 데이터 전송이 완료된 후에 연결을 안전하게 종료하기 위한 단계
	- FIN : 클라이언트에서 서버로 , 또는 서버에서 클라이언트로 연결 조율요청하는 패킷, 양방향이므로 어느 쪽이든 연결 종료 가능
	- ACK(Acknowledgment) : 데이터가 성공적으로 수신이 되었음을 나타내는 의미
	- 4way 핸드셰이크에서 두 번의 FIN 요청이 필요한 이유
		- TCP 연결이 전이중(duplex) 연결이기 때문, 전이중 연결에서 양쪽 모두 독립적으로 데이터를 전송할 수 있으므로, 한 쪽이 연결을 종료하더라도 다른 쪽에서는 계속해서 데이터를 전송할 수 있습니다.
![](attachments/Pasted%20image%2020260128230220.png)


- 왜 연결은 3way 고 종료는 4way 인가
	- 연결은 같이 시작이면 되고, 종료는 각자끝냈는지 확인해야 된다.
	- 각각데이터가 이동중이라 각자 끝냈는지 확인해야 된다.
	  
### 소켓 통신 수행과정: 송신, 수신 측 관점
---
![](attachments/Pasted%20image%2020260128232248.png)

- TCP Client 관점
	1. 클라이언트 소켓 생성 socket() 
	2. 연결 요청 connect() 3-way 핸드셰이크 수행 : IP 주소와 포트번호를 포함하여 연결요청 보낸다.
	3. 데이터 전송 write() : 각 패킷은 보내는 측 IP 주소와 포트번호, 받는 측 IP 주소와 포트 번호, 데이터 등의 정보를 포함합니다.
	4. 데이터 수신 read() : 서버 응답 값을 전달 받는다.
	5. 연결종료 close() 4-way 핸드셰이크 : 클라이언트는 서버에게 더이상 보내지 않겠다는 FIN 패킷 보냄
- Server 관점
	1. 서버 소켓 생성 - socket() : 클라이언트의 연결 요청 확인하기 위해 사용
	2. 서버 소켓 바인딩 - bind() : 서버 IP 주소와 포트 번호에 연결. 이 주소를 통해 외부와 연결
	3. 클라이언트 요청 대기 - listen() : 연결요청 기다림, 동시에 처리 가능한 연결 오청의 수를 지정가능
	4. 클라이언트 요청 수락 - accept() : 3-Way 핸드셰이크, 연결 수락되면 클라이언트와 통신을 위한 새로운 소켓 생성
	5. 데이터 수신 - read() : 클라이언트 데이터 수신
	6. 데이터 전송 - write() : 클라이언트 에게 데이터 전송 
	7. 데이터 수신 - read() : 클라이언트 추가 데이터 응답을 읽는다. 이 과정은 여러 번 반복될 수 있습니다.
	8. 연결종료 - close() : 4-Way 핸드 셰이크 - 서로 Fin 보내며 연결 종료 


### TCP/IP 네트워크 스택 이해하기 심화
---
데이터의 순서가 바뀌지 않으면서 데이터가 유실되지 않도록 빠르게 데이터를 보내려면 어떻게 보내야 될까? 라는 고민아래 설계


- Connection Oriented
	- 데이터를 보내기 전에 논리적 연결을 먼저 설정하고, 그 연결 상태를 유지 관리하면서 통신하는방식, <로컬 IP 주소, 로컬 포트번호, 리모트 IP 주소, 리모트 포트번호> 형태이다.
- Bidirectional byte stream
	- 양방향 데이터 통신을 하고, 바이트 스트림을 사용한다.

- In-order delivery
	- 송신자가 보낸 순서대로 수신자가 데이터를 받는다. 순서를 표시하기 위해 32-bit 정수 자료형을 사용.

- Reliability through ACK
	- 데이터 송신하고 수신자로 부터 ACK 받음 받지 않았으면, 송신자는 다시 데이터 보낸다.
	  송신자 TCP는 수신자로 부터 ACK를 받지 않은 데이터를 보관한다.

- Flow control
	- 송신자는 수신자가 받을 수 있을만큼의 데이터를 전송한다. 수신자가 자신이 받을 수 있는 바이트 수 를 송신자에게 전달한다. 송신자는 수신자가 receive window가 허용하는 바이트 수만큼 데이터를 전송한다.
- Congestion control
	- 네트워크 정체를 방지하기위해서 receive window, congetion window를 사용, 이는 네트워크에 유입되는 데이터양을 제어 하기위해서 사용한다. receive window와 마찬가지로 congestion window가 허용하는 바이트 수만큼 데이터를 전송 하며 TCP Vegas, Westwood, BIC, CUBIC 등 다양한 알고리즘이 있다. Flow control 과 달리 송신자가 단독으로 구현한다.


### 데이터 전송



![](attachments/Pasted%20image%2020260128222431.png)

- write 전송하는 부분이다. 전송할 User data 를 생성하고 write 시스템 콜을 통해 Kernel로 보낸다. 소켓은 이미 연결 되어 있다고 가정.

- 파일 레이어는 단순이 검사만 하고 소켓 구조체를 사용해서 소켓 함수를 호출한다.






### 참고자료
---
- http://d2.naver.com/helloworld/47667