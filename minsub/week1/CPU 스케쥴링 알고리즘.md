

```table-of-contents
```

## 1. 핵심 개념 

**CPU 스케줄링**이란 준비 큐(Ready Queue)에 있는 프로세스들 중 **어떤 프로세스에게 CPU를 할당할지 결정**하는 운영체제의 핵심 전략이다.


## 2. 스케줄링 분류 (중요 ⭐)
### 1) 비선점형 (Non-preemptive) 
- 프로세스가 스스로 CPU를 반납하거나 종료할 때까지 보장해준다. 
- **장점**: 문맥 교환(Context Switching) 오버헤드가 적다. 
- **단점**: 긴 작업이 하나 있으면 뒤에 있는 짧은 작업들이 하염없이 기다려야 한다. - **알고리즘**: `FCFS`, `SJF`, `HRN`
- FCFS (First Come, First Served)
	- ![[Pasted image 20260113005338.png]]
	- 가장 먼저 요청한 프로세스에 CPU를 할당해주는 선착순 방식이다.  
	  Convoy Effect(호위 효과)가 발생할 수 있다. Convoy 효과란 몇 개의 시간이 오래 걸리는 프로세스로 인해 전체 OS가 느려지는 현상을 말한다.

-  SJF (Shortest Job First)
	- ![[Pasted image 20260113005254.png]]
	- 실행 시간이 가장 짧은 프로세스를 먼저 실행하는 알고리즘이다. 하지만 실제로는 프로세스의 CPU 실행 시간을 예측하는 것이 어렵다는 문제가 존재한다. 또한 긴 시간을 필요로 하는 프로세스가 우선순위가 계속 밀려 실행되지 못하고 무기한으로 대기하게 되는 기아(Starvation) 현상이 일어날 수 있다.

- Priority
	- ![[Pasted image 20260113005539.png]]
	- 각각의 프로세스에 우선순위 넘버가 있는 알고리즘. 예를 들어 SJF 알고리즘의 경우, 낮은 우선 순위의 프로세스가 절대 실행되지 않는 기아(Starvation) 문제가 발생할 수 있는데 이를 해결하기 위해서 노화(aging)를 사용할 수 있다. 오래된 작업의 우선순위를 높여주는 식.


### 2) 선점형 (Preemptive) 
- OS가 강제로 CPU를 빼앗아 다른 프로세스에게 줄 수 있다. 
- **장점**: 긴급한 작업을 우선 처리하거나, 모든 프로세스에게 골고루 시간을 나눠줄 수 있다 (응답성 향상). 
- **단점**: 문맥 교환 오버헤드가 발생한다. - **알고리즘**: `Round Robin(RR)`, `SRT`, `Multi-level Queue`

- 라운드 로빈 (RR, Round Robin)
	- ![[Pasted image 20260113005728.png]]
		- 현대 컴퓨터가 사용하는 우선순위 스케줄링이다. 각각의 프로세스에 동일한 할당 시간을 부여해서 해당 시간 동안만 CPU를 이용하게 한다. 할당 시간 내에 처리를 완료하지 못하면 강제 중단 후 다음 작업으로 넘어가므로 선점형 방식이다.
		- 응답 시간을 빠르게 할 수 있다는 장점이 있지만 할당 시간이 길면 FCFS처럼 작동하고, 반대로 할당 시간이 너무 짧으면 process sharing이라고 부른다. 이것은 n개의 프로세스가 프로세서 속도의 1/n 씩으로 작동함을 의미한다.

- SRTF (Shortest Remaining Time First)
	- ![[Pasted image 20260113005830.png]]
		- 실행되고 있는 프로세스는 중단 없이 끝까지 실행하는 비선점형 SJF와는 다르게, 선점형 SRJ에서는 현재 실행되고 있는 프로세스의 남은 시간보다 더 빨리 끝날 수 있는 짧은 프로세스가 들어오면 현재 실행되는 프로세스를 중단하고 짧은 프로세스를 실행하도록 바꾸게 된다. SRTF(Shortest Remaining Time First)라고도 부른다.  이 스케줄링은 평균 대기 시간을 줄일 수 있지만 역시 다음 프로세스의 CPU burst time을 예측하는 것이 어렵다는 문제가 존재한다.

- 다단계 큐 (Multilevel Queue)
	![[Pasted image 20260113005911.png]]
	- 우선순위에 따른 준비 큐가 여러 개의 큐들로 나뉘고 각각의 큐는 각자의 스케줄링 알고리즘을 가지고 있다. 우선순위가 높은 큐부터 처리되기 때문에 낮은 큐의 프로세스가 처리가 안되는 기아(Starvation)현상이 나타날 수도 있으며, 각 큐 사이에서 프로세스들이 이동할 수 없어서 유연성이 떨어지는 특징이 있다.

##  면접 대비: 꼬리 물기 질문 (Deep Dive)

### Q1. 선점형과 비선점형 스케줄링의 차이점은 무엇인가요?
> **답변 가이드**: "강제성" 여부를 언급하고, 현대 OS(윈도우, 리눅스)는 멀티태스킹을 위해 대부분 **선점형**을 쓴다는 점을 강조.

**↳ 꼬리 질문 1-1. 그렇다면 선점형 스케줄링에서 발생할 수 있는 문제점은 무엇인가요?**
> **답변**: 잦은 문맥 교환(Context Switching)으로 인한 오버헤드, 그리고 두 프로세스가 서로 자원을 놓지 않아 발생하는 **교착 상태(Deadlock)**나 경쟁 상태(Race Condition)의 위험성을 언급.

---

### Q2. Round Robin 방식을 설명해 주시고, Time Quantum(할당 시간) 설정이 성능에 미치는 영향을 설명해 주세요.
> **답변 가이드**: 공평하게 시간을 나눠 쓰는 방식임을 설명.

**↳ 꼬리 질문 2-1. Time Quantum이 너무 작으면 어떻게 되나요?**
> **답변**: 문맥 교환이 너무 빈번하게 일어나 실제 작업 처리량보다 오버헤드가 더 커지는 비효율이 발생합니다.

**↳ 꼬리 질문 2-2. 반대로 Time Quantum이 너무 크면요?**
> **답변**: 사실상 FCFS(먼저 온 순서대로 처리)와 다를 바 없게 되어, 응답 속도가 느려집니다.

---

### Q3. 기아 현상(Starvation)이란 무엇이며, 이를 해결하기 위한 기법은 무엇인가요?
> **답변 가이드**: SJF나 우선순위 스케줄링에서 낮은 우선순위 작업이 무한히 대기하는 현상 설명.

**↳ 꼬리 질문 3-1. 에이징(Aging) 기법이 구체적으로 어떻게 동작하나요?**
> **답변**: 시스템에서 오랫동안 대기한 프로세스의 우선순위를 주기적으로 조금씩 높여주어, 결국에는 실행 권한을 얻게 만드는 기법입니다.

---

### Q4. (심화) 스레드(Thread)가 너무 많으면 왜 성능이 떨어지나요? CPU 스케줄링 관점에서 설명해 보세요.
> **답변 가이드**: 백엔드 핵심 질문. CPU 코어 개수는 한정적인데 실행할 스레드가 많으면 **Context Switching** 횟수가 폭증한다는 점을 논리적으로 설명. Cache Miss가 늘어나는 점까지 언급하면 가산점.



### 🖥️ 현대 운영체제의 스케줄링 (Real-world OS) 
현대 OS는 단일 알고리즘이 아닌 **복합적인(Hybrid) 방식**을 사용하며, 그 근간은 **MLFQ**이다. 
#### 1. MLFQ (Multi-Level Feedback Queue) 
- **개념**: 우선순위가 다른 여러 개의 큐를 두고, 프로세스의 행동(CPU 사용 패턴)에 따라 큐를 이동시키는 방식. 
- **핵심**: - 입출력(I/O) 위주의 작업(대화형) → **상위 큐** 유지 (빠른 응답) - CPU 위주의 무거운 작업 → **하위 큐**로 강등 (Time Slice 길게 줌) 
- **Aging/Boosting**: 기아 현상 방지를 위해 주기적으로 모든 프로세스를 상위 큐로 올림. #### 2. OS별 실제 구현 (Implementation)
- > [!INFO] 면접 포인트 > 
- **Linux**: **CFS (Completely Fair Scheduler)** 사용. 
- > - `Red-Black Tree` 자료구조 사용. 
- > - `vruntime`(가상 실행 시간)이 가장 적은 프로세스 선택. 
- > - **Windows**: **우선순위 기반(32단계)** + **Dynamic Boosting**.
- > - 포그라운드(현재 활성 창) 작업의 우선순위를 일시적으로 높여 반응성 확보.
