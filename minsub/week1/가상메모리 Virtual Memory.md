


### 개념
---
- OS 메모리 관리 기법중에 하나이다.
- 실제 물리적 메모리(RAM) 더 큰 연속적인 메모리 처럼 사용하게 보이게 하는 메모리 관리 기법
- 하드(HDD/SSD) 일부를 가상메모리로 사용하여 RAM 처럼 활용
- 프로그램 실행시 필요 부분만 RAM 에 올리고 , 나머지 디스크 저장
- 목적
	- **주소 공간의 추상화**: 각 프로세스는 독립된 가상 주소 공간을 가짐
	- **메모리 보호**: 프로세스 간 메모리 침범 방지
	- **효율적 자원 활용**: 실제로 사용 중인 데이터만 RAM에 적재

- CPU 에서 메모리 접근 방식
	- CPU에서 페이지 테이블에 가서 물어보고 오려면 시간이 걸리니까 **"CPU 내부에서 미리 자주 사용하는 주소는 가지고 있자" 는 것이 CPU에서 캐시의 개념**이다.
### FLOW
---
- TLB HIT
1. CPU → 가상 주소 생성
2. MMU → TLB 조회
3. 즉시 물리 주소 획득
4. 메모리 접근

- TLB Miss(Page Table Hit)
1. CPU → 가상 주소
2. MMU → TLB Miss
3. Page Table Walk
4. TLB 갱신
5. 메모리 접근

- Page Fault
1. CPU → 가상 주소
2. MMU → PTE invalid
3. CPU Trap
4. OS 개입
5. Disk → RAM
6. Page Table 수정
7. 재실행

### 동작 원리
---

프로세스는 연속된 큰 메모리를 혼자쓰고 있다고 생각
- 가상주소공간(Virtual Address Space)
	- 프로세스가 인식하는 논리적 메모리 공간, 프로세스는 독립적인 가상 주소 공간을 가진다.
	- 실제 RAM 과 1:1 대응 되지는 않는다.
- 페이지(Page) 단위 관리
	- 메모리 관리 최소단위 (4KB)
	- 부분적제, 부분회수, 부분교체 가능
- 페이지 테이블(Page Table)
	- 가상페이즈 ->  실제 위치 매핑정보
	- 매핑대상 
		- RAM (physical frame)
		- Swap 영역
		- 파일

![](attachments/Pasted%20image%2020260124161059.png)

### Swap 영역
---
- RAM 이 부족할때 하드디스크 Swap Space 에 저장하는과정
- Swap 영역에 있는 프로세스가 Swap 영역에서 벗어나는 방법은 다시 실행되거나, 죽거나
- Swap 영역에 너무 프로세스가 자주 이동여하면 성능저하가 심해진다.

### MLU(Memory Management Unit) , TLB(Translation Lookaside Buffer)
---
- TLB
	- CPU 내부적으로 사용하는 캐시
	- 자주사용하는 가상주소에대한 물리주소를 가지고 있음

### PageTable
---
- Page Table은 RAM에 존재하는 실제 주소(Physical Address)와 HDD에 존재하는 가상 주소(Virtual Address)를 매핑한 테이블 입니다.

![](attachments/Pasted%20image%2020260124141027.png)

- 페이지 : 가상 메모리를 일정 크기(4KB, 8KB)로 나눈 단위
- 프레임 : 물리 메모리를 일정 크기 단위로 나눈 블록으로 , 페이지 크기와 같다.

### 페이지 교체 정책 
---
모든 물리적 프레임이 어떤페이지에 할당된 상태일때 작동한다.
- 프레임에 매핑된 페이지를 변경

페이지 교체 알고리즘
- OPT (Optimal Replacement)
- FIFO(First In First Out) 가장 먼저 들어온 페이지 교체
	- 구현 단순, 오버헤드 최소화
	- 사용여부 고려 안함, Belady’s Anomaly 발생
		- 예) 메모리를 더 줬는데 더 자주 깨진다,  “이상 현상”
		- 사용 했는지 체크 하지 않아 이상현상 더 발생 할 수 있음
- LRU(Least Recently Used) - 가장 오랫동안 사용하지 않은 페이지를 교체
	- 사용된 시간을 알수있는 부분을 저장하여 가장 오랫동안 참조되지 않는 데이터를 제거
	- 단점
		- 참조된 페이지 시간을 기록해야 하므로 막대한 오버헤드가 발생
- LFU(Least Frequently Used) - 참조 횟수가 가장 낮은 페이지를 교체
	- 참조횟수를 통해 장기적 시간규모에서의 참조성향 고려할 수 있음
	- 단점
		- 오래된 과거 기록에 묶임
		- 가장 최근에 불러온 페이지가 교체될 수 있음, 구현 더 복잡, 막대한 오버헤드


### 세그멘테이션(Segmentation)
---
- 세그멘테이션은 프로세스의 주소 공간을 의미 단위(논리 단위)로 나누는 메모리 관리 기법입니다.
- 의미단위는 코드, 데이터, 스텍, 힙

![](attachments/Pasted%20image%2020260124170409.png)

- 장점
	- 논리적 보호가 쉬움
		- 코드 세그먼트: read + execute
		- 데이터 세그먼트: read + write
		- 스택: grow down
- 단점
	- 메모리 중간 중간 빈곳이 많아짐, 메모리 낭비

### 정리
---
- 가상메모리
	- 장점
		- 물리적 RAM 크기보다 더 큰 프로그램 실행 가능
		- 여러 프로그램 동시 실행 가능
		- 프로세스간 메모리 보호
		- 운영체제가 자동으로 메모리관리
	- 단점
		- 하드디스크 사용량 증가
		- RAM 보다 속도가 떨어져 성능 저하 가능
		- 페이지 폴트 발생 시 CPU가 디스크 접근으로 인해 성능 저하
		  
- 세그멘테이션
	1.	프로세스가 실제로 7KB 필요
	2.	코드 3KB, 데이터 2KB, 스택 2KB 등 가변 크기
	3.	각 세그먼트는 연속된 물리 메모리 필요
	4.	총 7KB를 정확히 할당
	5.	중간에 빈 공간이 생기면 7KB 연속 공간이 없어서 실패 가능
	6.	→ 외부 단편화 발생
- 페이징
	1.	페이지 크기 4KB
	2.	프로세스가 7KB 접근
	3.	가상 페이지 2개 필요
	4.	물리 프레임 2개 할당 (8KB)
	5.	실제 사용 7KB, 낭비 1KB
	6.	→ 내부 단편화 발생
- 핵심 차이
	- 세그멘테이션: 필요한 만큼 정확히, 대신 연속 공간 요구
	- 페이징: 조금 낭비, 대신 항상 배치 가능
		

	- 외부 단편화 (External Fragmentation)
		- 메모리는 남아 있는데 연속된 공간이 없어서 할당을 못 하는 상태
		- (외부)에 조각조각 흩어짐, 배치 실패 문제
	- 내부 단편화 (Internal Fragmentation)
		- 할당은 되었지만 할당된 블록 안에서 남는 공간이 생기는 상태
		- 블록 내부에서 남음, 내부 낭비 문제
